"use strict";(self.webpackChunkqodly=self.webpackChunkqodly||[]).push([["13742"],{9694:function(e,r,n){n.r(r),n.d(r,{metadata:()=>t,contentTitle:()=>a,default:()=>h,assets:()=>i,toc:()=>d,frontMatter:()=>l});var t=JSON.parse('{"id":"language/commands/onErrCall","title":"onErrCall","description":"onErrCall( errorMethod string , scope : integer )","source":"@site/versioned_docs/version-1.1.0/language/commands/onErrCall.md","sourceDirName":"language/commands","slug":"/language/commands/onErrCall","permalink":"/docs/language/commands/onErrCall","draft":false,"unlisted":false,"editUrl":"https://github.com/qodly/docs/issues/new?title=Comment%20on%20language%2Fcommands%2FonErrCall.md%20(1.1.0)&body=Share%20any%20feedback%20about%20this%20page%20%E2%80%94%20report%20issues%2C%20suggest%20improvements%2C%20or%20tell%20us%20what%E2%80%99s%20helpful.%0A%0AIf%20it%E2%80%99s%20an%20issue%3A%0A-%20What%E2%80%99s%20the%20issue%3F%20(e.g.%2C%20typo%2C%20incorrect%20information%2C%20unclear%20explanation)%0A-%20Where%20is%20it%3F%20(e.g.%2C%20section%20name%2C%20specific%20paragraph%2C%20or%20line)%0A%0AThank%20you%20for%20helping%20us%20improve!%20%F0%9F%9A%80%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20","tags":[],"version":"1.1.0","frontMatter":{"id":"onErrCall","title":"onErrCall"},"sidebar":"Develop","previous":{"title":"objectValues","permalink":"/docs/language/commands/objectValues"},"next":{"title":"openDatastore","permalink":"/docs/language/commands/openDatastore"}}'),o=n("85893"),s=n("50065");let l={id:"onErrCall",title:"onErrCall"},a=void 0,i={},d=[{value:"Description",id:"description",level:4},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"See also",id:"see-also",level:4}];function c(e){let r={a:"a",code:"code",em:"em",h4:"h4",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"onErrCall"}),"( ",(0,o.jsx)(r.em,{children:"errorMethod"})," : string )",(0,o.jsx)("br",{}),(0,o.jsx)(r.strong,{children:"onErrCall"}),"( ",(0,o.jsx)(r.em,{children:"errorMethod"})," : string , ",(0,o.jsx)(r.em,{children:"scope"})," : integer )"]}),"\n",(0,o.jsxs)(r.table,{children:[(0,o.jsx)(r.thead,{children:(0,o.jsxs)(r.tr,{children:[(0,o.jsx)(r.th,{children:"Parameter"}),(0,o.jsx)(r.th,{children:"Type"}),(0,o.jsx)(r.th,{style:{textAlign:"center"}}),(0,o.jsx)(r.th,{children:"Description"})]})}),(0,o.jsxs)(r.tbody,{children:[(0,o.jsxs)(r.tr,{children:[(0,o.jsx)(r.td,{children:"errorMethod"}),(0,o.jsx)(r.td,{children:"string"}),(0,o.jsx)(r.td,{style:{textAlign:"center"},children:"\u2192"}),(0,o.jsx)(r.td,{children:"Parameters used to build the error"})]}),(0,o.jsxs)(r.tr,{children:[(0,o.jsx)(r.td,{children:"scope"}),(0,o.jsx)(r.td,{children:"integer"}),(0,o.jsx)(r.td,{style:{textAlign:"center"},children:"\u2192"}),(0,o.jsx)(r.td,{children:"Scope for the error method"})]})]})]}),"\n",(0,o.jsx)(r.h4,{id:"description",children:"Description"}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.code,{children:"onErrCall"})," command installs the project method, whose name you pass in ",(0,o.jsx)(r.em,{children:"errorMethod"}),", as the method for catching (trapping) errors for the defined execution context in the current project. This method is called the ",(0,o.jsx)(r.a,{href:"/docs/language/basics/lang-errors#installing-an-error-handling-method",children:(0,o.jsx)(r.strong,{children:"error-handling method"})}),"."]}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.em,{children:"scope"})," of the command designates the execution context from where an error will trigger the call of the ",(0,o.jsx)(r.em,{children:"errorMethod"}),". By default, if the ",(0,o.jsx)(r.em,{children:"scope"})," parameter is omitted, the scope of the command is the local execution context, i.e. the current process. You can pass one of the following constants in the ",(0,o.jsx)(r.em,{children:"scope"})," parameter:"]}),"\n",(0,o.jsxs)(r.table,{children:[(0,o.jsx)(r.thead,{children:(0,o.jsxs)(r.tr,{children:[(0,o.jsx)(r.th,{children:"Constant"}),(0,o.jsx)(r.th,{children:"Value"}),(0,o.jsx)(r.th,{children:"Description"})]})}),(0,o.jsxs)(r.tbody,{children:[(0,o.jsxs)(r.tr,{children:[(0,o.jsx)(r.td,{children:"kErrorsFromComponents"}),(0,o.jsx)(r.td,{children:"2"}),(0,o.jsxs)(r.td,{children:["Only errors generated from the components installed in the application will call ",(0,o.jsx)(r.em,{children:"errorMethod"}),". Note that, if an error-handling method is defined in a component, it is called in case of error in the component, and the ",(0,o.jsx)(r.code,{children:"kErrorsFromComponents"})," error handler set in the host application is not called."]})]}),(0,o.jsxs)(r.tr,{children:[(0,o.jsx)(r.td,{children:"kGlobal"}),(0,o.jsx)(r.td,{children:"1"}),(0,o.jsxs)(r.td,{children:["All errors that occurred in the application, whatever the process (except components), will call ",(0,o.jsx)(r.em,{children:"errorMethod"}),". Note that, if a ",(0,o.jsx)(r.code,{children:"kLocal"})," is also defined for a process, the ",(0,o.jsx)(r.code,{children:"kGlobal"})," is not called. This principle allows you to define a generic error-handling method that will catch all errors, while local error-handling methods can be set for some specific processes."]})]}),(0,o.jsxs)(r.tr,{children:[(0,o.jsx)(r.td,{children:"kLocal"}),(0,o.jsx)(r.td,{children:"0"}),(0,o.jsxs)(r.td,{children:["(default if ",(0,o.jsx)(r.em,{children:"scope"})," parameter is omitted) Only errors that occurred in the current process will call ",(0,o.jsx)(r.em,{children:"errorMethod"}),". You can have one error-handling method per process at a time, but you can have different error-handling methods for several processes."]})]})]})]}),"\n",(0,o.jsxs)(r.p,{children:["To stop the trapping of errors, call ",(0,o.jsx)(r.code,{children:"onErrCall"})," again with the desired ",(0,o.jsx)(r.em,{children:"scope"})," parameter (if any) and pass an empty string in ",(0,o.jsx)(r.em,{children:"errorMethod"}),"."]}),"\n",(0,o.jsxs)(r.p,{children:["You can use the ",(0,o.jsx)(r.a,{href:"/docs/language/commands/lastErrors",children:(0,o.jsx)(r.code,{children:"lastErrors"})})," and ",(0,o.jsx)(r.a,{href:"/docs/language/commands/callChain",children:(0,o.jsx)(r.code,{children:"callChain"})}),' commands to obtain the error sequence (i.e., the error "stack") at the origin of the interruption (see also ',(0,o.jsx)(r.a,{href:"/docs/language/basics/lang-errors#handling-errors-within-the-method",children:"Handling errors within the method"}),")."]}),"\n",(0,o.jsx)(r.p,{children:"The error-handling method should manage the error in an appropriate way or present an error message to the user. Errors can be generated by the Qodly database engine (e.g. saving an entity causes the violation of a rule), the Qodly environment (e.g. have enough memory for loading a blob)..."}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.a,{href:"/docs/language/commands/abort",children:(0,o.jsx)(r.code,{children:"abort"})})," command can be used to terminate processing. If you don't call ",(0,o.jsx)(r.code,{children:"abort"})," in the error-handling method, Qodly returns to the interrupted method and continues to execute the method. Use the ",(0,o.jsx)(r.code,{children:"abort"})," command when an error cannot be recovered."]}),"\n",(0,o.jsxs)(r.p,{children:["If an error occurs in the error-handling method itself, Qodly takes over error handling. Therefore, you should make sure that the error-handling method cannot generate an error. Also, you cannot use ",(0,o.jsx)(r.code,{children:"onErrCall"})," inside the error-handling method."]}),"\n",(0,o.jsx)(r.h4,{id:"example-1",children:"Example 1"}),"\n",(0,o.jsx)(r.p,{children:"You want to install a global error handler:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-qs",children:'\nonErrCall("myGlobalErrorHandler",kGlobal)\n\n'})}),"\n",(0,o.jsx)(r.h4,{id:"example-2",children:"Example 2"}),"\n",(0,o.jsx)(r.p,{children:"Here is a simple error-handling system:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-qs",children:'\n// installing the error handling method\n onErrCall("errorMethod")\n //... executing code\n onErrCall("") //giving control back to Qodly\n\n'})}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-qs",children:'// errorMethod project method  \nvar errNum : integer\nvar message : string\nerrNum = lastErrors[0].errCode\nif(errNum  !=  1006) //this is not a user interruption\n   message = "Error "+string(errNum)+" occurred ("+lastErrors[0].message+").")\nend\n'})}),"\n",(0,o.jsx)(r.h4,{id:"see-also",children:"See also"}),"\n",(0,o.jsx)(r.p,{children:(0,o.jsx)(r.a,{href:"/docs/language/WebFormClass#seterror",children:(0,o.jsx)(r.code,{children:".setError()"})})})]})}function h(e={}){let{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},50065:function(e,r,n){n.d(r,{Z:function(){return a},a:function(){return l}});var t=n(67294);let o={},s=t.createContext(o);function l(e){let r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);