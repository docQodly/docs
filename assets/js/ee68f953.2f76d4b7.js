"use strict";(self.webpackChunkqodly=self.webpackChunkqodly||[]).push([[6330],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(t),u=a,m=p["".concat(s,".").concat(u)]||p[u]||h[u]||o;return t?r.createElement(m,l(l({ref:n},d),{},{components:t})):r.createElement(m,l({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=u;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[p]="string"==typeof e?e:a,l[1]=i;for(var c=2;c<o;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},52402:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=t(87462),a=(t(67294),t(3905));const o={id:"lang-errors",title:"Error handling"},l=void 0,i={unversionedId:"language/basics/lang-errors",id:"language/basics/lang-errors",title:"Error handling",description:"Error handling is the process of anticipating and responding to errors that might occur in your application. Qodly provides a comprehensive support for catching and reporting errors at runtime, as well as for investigating their conditions.",source:"@site/docs/language/basics/lang-errors.md",sourceDirName:"language/basics",slug:"/language/basics/lang-errors",permalink:"/docs/language/basics/lang-errors",draft:!1,editUrl:"https://github.com/docQodly/docs/edit/main/docs/language/basics/lang-errors.md",tags:[],version:"current",frontMatter:{id:"lang-errors",title:"Error handling"},sidebar:"Develop",previous:{title:"Control flow",permalink:"/docs/language/basics/lang-control-flow"},next:{title:"Identifiers",permalink:"/docs/language/basics/lang-identifiers"}},s={},c=[{value:"Error or status",id:"error-or-status",level:2},{value:"Installing an error-handling method",id:"installing-an-error-handling-method",level:2},{value:"Scope and components",id:"scope-and-components",level:3},{value:"Handling errors within the method",id:"handling-errors-within-the-method",level:3},{value:"Example",id:"example",level:4},{value:"Using an empty error-handling method",id:"using-an-empty-error-handling-method",level:3},{value:"try(expression)",id:"tryexpression",level:2},{value:"Examples",id:"examples",level:3},{value:"try...catch...end",id:"trycatchend",level:2},{value:"Example",id:"example-1",level:3}],d={toc:c};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Error handling is the process of anticipating and responding to errors that might occur in your application. Qodly provides a comprehensive support for catching and reporting errors at runtime, as well as for investigating their conditions."),(0,a.kt)("p",null,"Error handling meets two main needs:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"finding out and fixing potential errors and bugs in your code during the development phase,"),(0,a.kt)("li",{parentName:"ul"},"catching and recovering from unexpected errors in deployed applications; in particular, you can replace system error messages with you own interface.")),(0,a.kt)("p",null,"Basically, there are two ways to handle errors in QodlyScript. You can:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#installing-an-error-handling-method"},"install an error-handling method"),", or"),(0,a.kt)("li",{parentName:"ul"},"use a ",(0,a.kt)("a",{parentName:"li",href:"#tryexpression"},(0,a.kt)("inlineCode",{parentName:"a"},"try()")," keyword")," or a ",(0,a.kt)("a",{parentName:"li",href:"#trycatchend"},(0,a.kt)("inlineCode",{parentName:"a"},"try/catch")," structure")," before pieces of code that call a function, method, or expression that can throw an error.")),(0,a.kt)("h2",{id:"error-or-status"},"Error or status"),(0,a.kt)("p",null,"Many QuodlyScript class functions, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"entity.save()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"transporter.send()"),", return a ",(0,a.kt)("em",{parentName:"p"},"status"),' object. This object is used to store "predictable" errors in the runtime context, e.g. invalid password, locked entity, etc., that do not stop program execution. This category of errors can be handled by regular code.'),(0,a.kt)("p",null,'Other "unpredictable" errors include write error, network failure, or in general any unexpected interruption. This category of errors generates exceptions and needs to be handled through an error-handling method or a ',(0,a.kt)("inlineCode",{parentName:"p"},"try()")," keyword.  "),(0,a.kt)("h2",{id:"installing-an-error-handling-method"},"Installing an error-handling method"),(0,a.kt)("p",null,"In Quodly, all errors can be caught and handled by specific methods, named ",(0,a.kt)("strong",{parentName:"p"},"error-handling")," (or ",(0,a.kt)("strong",{parentName:"p"},"error-catching"),") methods."),(0,a.kt)("p",null,"Once installed, error handlers are automatically called in case of error in the Qodly application. A different error handler can be called depending on the execution context (see below).  "),(0,a.kt)("p",null,"To ",(0,a.kt)("em",{parentName:"p"},"install")," an error-handling method, you just need to call the ",(0,a.kt)("a",{parentName:"p",href:"/docs/language/commands/onErrCall"},(0,a.kt)("inlineCode",{parentName:"a"},"onErrCall"))," command with the method name and (optionnally) scope as parameters. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'onErrCall("IO_Errors",ek local) //Installs a local error-handling method\n')),(0,a.kt)("p",null,"To stop catching errors for an execution context and give back hand, call ",(0,a.kt)("inlineCode",{parentName:"p"},"onErrCall")," with an empty string:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'onErrCall("",ek local) //gives back control for the local process\n')),(0,a.kt)("p",null,"The  ",(0,a.kt)("a",{parentName:"p",href:"/docs/language/commands/methodCalledOnError"},(0,a.kt)("inlineCode",{parentName:"a"},"methodCalledOnError"))," command allows you to know the name of the method installed by ",(0,a.kt)("inlineCode",{parentName:"p"},"onErrCall")," for the current process. It is particularly useful in the context of generic code because it enables you to temporarily change and then restore the error-catching method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},' var methCurrent : string\n methCurrent = methodCalledOnError(ek local)\n onErrCall("NewMethod",ek local)\n  ...//Processing with specific error handling\n  //Reinstallation of previous method\n onErrCall(methCurrent,ek local)\n\n')),(0,a.kt)("h3",{id:"scope-and-components"},"Scope and components"),(0,a.kt)("p",null,"An error-handling method can be set for different execution contexts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"for the ",(0,a.kt)("strong",{parentName:"li"},"current process"),"- a local error handler will be only called for errors that occurred in the current process of the current project,"),(0,a.kt)("li",{parentName:"ul"},"for the ",(0,a.kt)("strong",{parentName:"li"},"whole application"),"- a global error handler will be called for all errors that occurred in the application execution context of the current project.")),(0,a.kt)("p",null,"Examples:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'onErrCall("IO_Errors",ek local) //Installs a local error-handling method\nonErrCall("globalHandler",ek global) //Installs a global error-handling method\n')),(0,a.kt)("p",null,'You can install a global error handler that will serve as "fallback" and specific local error handlers for certain processes.'),(0,a.kt)("p",null,"You can define a single error-catching method for the whole application or different methods per application module. However, only one method can be installed per execution context and per project. When an error occurs, only one method is called."),(0,a.kt)("h3",{id:"handling-errors-within-the-method"},"Handling errors within the method"),(0,a.kt)("p",null,"Within a custom error method, you can use several commands that will help you identifying the error:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the ",(0,a.kt)("a",{parentName:"li",href:"/docs/language/commands/lastErrors"},(0,a.kt)("inlineCode",{parentName:"a"},"lastErrors"))," command that returns a collection of the current stack of errors that occurred in the Qodly application."),(0,a.kt)("li",{parentName:"ul"},"the ",(0,a.kt)("a",{parentName:"li",href:"/docs/language/commands/callChain"},(0,a.kt)("inlineCode",{parentName:"a"},"callChain"))," command that returns a collection of objects describing each step of the method call chain within the current process.")),(0,a.kt)("h4",{id:"example"},"Example"),(0,a.kt)("p",null,"Here is a simple error-handling system:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'// installing the error handling method\n onErrCall("errorMethod")\n //... executing code\n onErrCall("") //giving control back to Qodly\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'// errorMethod project method  \nvar errNum : integer\nvar message : string\nerrNum = lastErrors[0].errCode\nif(errNum  !=  1006) //this is not a user interruption\n   message = "Error "+string(errNum)+" occurred ("+lastErrors[0].message+").")\nend\n')),(0,a.kt)("h3",{id:"using-an-empty-error-handling-method"},"Using an empty error-handling method"),(0,a.kt)("p",null,"If you mainly want the standard error messages to be hidden, you can install an empty error-handling method. The ",(0,a.kt)("a",{parentName:"p",href:"/docs/language/commands/lastErrors"},(0,a.kt)("inlineCode",{parentName:"a"},"lastErrors"))," command can be called in any method, i.e. outside of the error-handling method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'onErrCall("emptyMethod") //emptyMethod exists but is empty\nvar errNum : integer\nvar errText : string\nif (errNum == -43)\n    errText = "File not found."\nend\nonErrCall("")\n')),(0,a.kt)("h2",{id:"tryexpression"},"try(expression)"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"try(expression)")," statement allows you to test a single-line expression in its actual execution context (including, in particular, variable values) and to intercept errors it throws so that the Qodly error dialog box is not displayed. Using ",(0,a.kt)("inlineCode",{parentName:"p"},"try(expression)")," provides an easy way to handle simple error cases with a very low number of code lines, and without requiring an error-handling method. "),(0,a.kt)("p",null,"The formal syntax of the ",(0,a.kt)("inlineCode",{parentName:"p"},"try(expression)")," statement is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},"\ntry (expression) : any | undefined\n\n")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"expression")," can be any valid expression. "),(0,a.kt)("p",null,"If an error occurred during its execution, it is intercepted and no error dialog is displayed, whether an ",(0,a.kt)("a",{parentName:"p",href:"#installing-an-error-handling-method"},"error-handling method")," was installed or not before the call to ",(0,a.kt)("inlineCode",{parentName:"p"},"try()"),". If ",(0,a.kt)("em",{parentName:"p"},"expression")," returns a value, ",(0,a.kt)("inlineCode",{parentName:"p"},"try()")," returns the last evaluated value, otherwise it returns ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),". "),(0,a.kt)("p",null,"You can handle the error(s) using the ",(0,a.kt)("a",{parentName:"p",href:"/docs/language/commands/lastErrors"},(0,a.kt)("inlineCode",{parentName:"a"},"lastErrors"))," command. If ",(0,a.kt)("em",{parentName:"p"},"expression")," throws an error within a stack of ",(0,a.kt)("inlineCode",{parentName:"p"},"try()")," calls, the execution flow stops and returns to the latest executed ",(0,a.kt)("inlineCode",{parentName:"p"},"try()")," (the first found back in the call stack). "),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"If an ",(0,a.kt)("a",{parentName:"p",href:"#installing-an-error-handling-method"},"error-handling method")," is installed by ",(0,a.kt)("em",{parentName:"p"},"expression"),", it is called in case of error. ")),(0,a.kt)("h3",{id:"examples"},"Examples"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"You want to display the contents of a file if the file can be open without error, and if its contents can be read. You can write:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'var text : string\nvar file : 4D.File = file("/RESOURCES/myFile.txt")\nvar fileHandle : 4D.FileHandle = try(file.open())\nif (fileHandle != null)\n  text = try(fileHandle.readText()) || "Error reading the file"\nend\n')),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"You want to handle the divide by zero error. In this case, you want to return 0 and log an error:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'function divide( p1 : real , p2 : real) -> result : real\n  if (p2 == 0)\n     result = 0 //only for clarity (0 is the default for reals)\n     throw(-12345 , "Division by zero")\n  else\n    result = p1/p2\n  end\n\nfunction test() -> result : real\n  var info = string\n  result = try(divide(p1 , p2))\n  if (lastErrors != null)\n    info = "Error"\n  end\n\n')),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"You want to handle both ",(0,a.kt)("a",{parentName:"li",href:"#error-or-status"},"predictable and non-predictable")," errors:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qs"},'var e = ds.Employee.new()\nvar status = object\nvar info = string\ne.name = "Smith"\nstatus = try(e.save()) //catch predictable and non-predictable errors\nif (status.success)\n   info = "Success"\nelse\n   info = "Error: "+jsonStringify(status.errors)\nend\n\n')),(0,a.kt)("h2",{id:"trycatchend"},"try...catch...end"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"try...catch...end")," structure allows you to test a block code in its actual execution context (including, in particular, variable values) and to intercept errors it throws so that the no Qodly error is displayed."),(0,a.kt)("p",null,"Unlike the ",(0,a.kt)("inlineCode",{parentName:"p"},"try(expression)")," keyword that evaluates a single-line expression, the ",(0,a.kt)("inlineCode",{parentName:"p"},"try...catch...end")," structure allows you to evaluate any code block, from the most simple to the most complex, without requiring an error-handling method. In addition, the ",(0,a.kt)("inlineCode",{parentName:"p"},"catch")," block can be used to handle the error in any custom way. "),(0,a.kt)("p",null,"The formal syntax of the ",(0,a.kt)("inlineCode",{parentName:"p"},"try...catch...end")," structure is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-4d"},"\ntry \n    statement(s) // Code to evaluate\ncatch\n    statement(s) // Code to execute in case of error\nend\n\n")),(0,a.kt)("p",null,"The code placed between the ",(0,a.kt)("inlineCode",{parentName:"p"},"try")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"catch")," keywords is first executed, then the flow depends on the error(s) encountered during this execution. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If no error is thrown, the code execution continues after the corresponding ",(0,a.kt)("inlineCode",{parentName:"li"},"end")," keyword. The code placed between the ",(0,a.kt)("inlineCode",{parentName:"li"},"catch")," and the ",(0,a.kt)("inlineCode",{parentName:"li"},"end")," keywords is not executed."),(0,a.kt)("li",{parentName:"ul"},"If the code block execution throws a ",(0,a.kt)("em",{parentName:"li"},"non-deferred error"),", the execution flow stops and executes the corresponding ",(0,a.kt)("inlineCode",{parentName:"li"},"catch")," code block. "),(0,a.kt)("li",{parentName:"ul"},"If the code block execution throws a ",(0,a.kt)("em",{parentName:"li"},"deferred error"),", the execution flow continues until the end of the ",(0,a.kt)("inlineCode",{parentName:"li"},"try")," block and then executes the corresponding ",(0,a.kt)("inlineCode",{parentName:"li"},"catch")," code block. ")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"If a ",(0,a.kt)("em",{parentName:"p"},"deferred")," error is thrown outside of the ",(0,a.kt)("inlineCode",{parentName:"p"},"try")," block, the code execution continues until the end of the method or function. ")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"For more information on ",(0,a.kt)("em",{parentName:"p"},"deferred")," and ",(0,a.kt)("em",{parentName:"p"},"non-deferred")," errors, please refer to the ",(0,a.kt)("a",{parentName:"p",href:"/docs/language/commands/throw"},(0,a.kt)("inlineCode",{parentName:"a"},"throw"))," command description.")),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"catch")," code block, you can handle the error(s) using standard error handling commands. The ",(0,a.kt)("a",{parentName:"p",href:"/docs/language/commands/lastErrors"},(0,a.kt)("inlineCode",{parentName:"a"},"lastErrors"))," command contains the last errors collection. You can ",(0,a.kt)("a",{parentName:"p",href:"#installing-an-error-handling-method"},"declare an error-handling method")," in this code block, in which case it is called in case of error."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"If an ",(0,a.kt)("a",{parentName:"p",href:"#installing-an-error-handling-method"},"error-handling method")," is installed in the code placed between the ",(0,a.kt)("inlineCode",{parentName:"p"},"try")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"catch")," keywords, it is called in case of error. ")),(0,a.kt)("h3",{id:"example-1"},"Example"),(0,a.kt)("p",null,"Combining transactions and ",(0,a.kt)("inlineCode",{parentName:"p"},"try...catch...end")," structures allows writing secured code for critical features. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-qodly"},"function createInvoice(customer : cs.customerEntity, items : collection, invoiceRef : string) : cs.invoiceEntity\n    var newInvoice : cs.invoiceEntity\n    var newInvoiceLine : cs.invoiceLineEntity\n    var item : object\n    ds.startTransaction()\n    try\n        newInvoice=this.new()\n        newInvoice.customer=customer\n        newInvoice.invoiceRef=invoiceRef\n        forEach (item, items)\n            newInvoiceLine=ds.invoiceLine.new()\n            newInvoiceLine.item=item.item\n            newInvoiceLine.amountitem.amount\n            newInvoiceLine.invoice=newInvoice\n            //call other specific functions to validate invoiceline\n            newInvoiceLine.save()\n        end \n        newInvoice.save()\n        ds.validateTransaction()\n    catch\n        ds.cancelTransaction()\n        ds.logErrors(lastErrors)\n        newInvoice=null\n    end\n    return newInvoice\n\n")))}p.isMDXComponent=!0}}]);