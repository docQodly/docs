"use strict";(self.webpackChunkqodly=self.webpackChunkqodly||[]).push([["36542"],{32265:function(e,n,s){s.r(n),s.d(n,{metadata:()=>i,contentTitle:()=>l,default:()=>h,assets:()=>a,toc:()=>c,frontMatter:()=>o});var i=JSON.parse('{"id":"language/SignalClass","title":"Signal","description":"Signals are tools provided by the QodlyScript language to manage interactions and avoid conflicts between worker processes in a multiprocess application. Signals allow you to make sure one or more process(es) will wait for a specific task to be completed before continuing execution. Any process can wait and/or release a signal.","source":"@site/versioned_docs/version-1.0.0/language/SignalClass.md","sourceDirName":"language","slug":"/language/SignalClass","permalink":"/docs/1.0.0/language/SignalClass","draft":false,"unlisted":false,"editUrl":"https://github.com/qodly/docs/issues/new?title=Comment%20on%20language%2FSignalClass.md%20(1.0.0)&body=Share%20any%20feedback%20about%20this%20page%20%E2%80%94%20report%20issues%2C%20suggest%20improvements%2C%20or%20tell%20us%20what%E2%80%99s%20helpful.%0A%0AIf%20it%E2%80%99s%20an%20issue%3A%0A-%20What%E2%80%99s%20the%20issue%3F%20(e.g.%2C%20typo%2C%20incorrect%20information%2C%20unclear%20explanation)%0A-%20Where%20is%20it%3F%20(e.g.%2C%20section%20name%2C%20specific%20paragraph%2C%20or%20line)%0A%0AThank%20you%20for%20helping%20us%20improve!%20%F0%9F%9A%80%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20","tags":[],"version":"1.0.0","frontMatter":{"id":"SignalClass","title":"Signal"},"sidebar":"Develop","previous":{"title":"Session","permalink":"/docs/1.0.0/language/SessionClass"},"next":{"title":"SMTPTransporter","permalink":"/docs/1.0.0/language/SMTPTransporterClass"}}'),t=s("85893"),r=s("50065");let o={id:"SignalClass",title:"Signal"},l=void 0,a={},c=[{value:"Signal object",id:"signal-object",level:3},{value:"Working with signals",id:"working-with-signals",level:3},{value:"Example",id:"example",level:3},{value:"Functions and properties",id:"functions-and-properties",level:3},{value:".description",id:"description",level:2},{value:"Description",id:"description-1",level:4},{value:".signaled",id:"signaled",level:2},{value:"Description",id:"description-2",level:4},{value:".trigger()",id:"trigger",level:2},{value:"Description",id:"description-3",level:4},{value:".wait()",id:"wait",level:2},{value:"Description",id:"description-4",level:4}];function d(e){let n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Signals are tools provided by the QodlyScript language to manage interactions and avoid conflicts between worker processes in a multiprocess application. Signals allow you to make sure one or more process(es) will wait for a specific task to be completed before continuing execution. Any process can wait and/or release a signal."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/docs/1.0.0/language/commands/semaphore",children:"Semaphores"})," can also be used to manage interactions. Semaphores allow you to make sure that two or more processes do not modify the same resource (file, record...) at the same time. Only the process that sets the semaphore can remove it."]})}),"\n",(0,t.jsx)(n.h3,{id:"signal-object",children:"Signal object"}),"\n",(0,t.jsx)(n.p,{children:"A signal is a shared object that must be passed as a parameter to commands that call or create workers."}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"4D.Signal"})," object contains the following built-in methods and properties:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#wait",children:(0,t.jsx)(n.code,{children:".wait()"})})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#trigger",children:(0,t.jsx)(n.code,{children:".trigger()"})})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#signaled",children:(0,t.jsx)(n.code,{children:".signaled"})})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#description",children:(0,t.jsx)(n.code,{children:".description"})}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Any worker/process calling the ",(0,t.jsx)(n.code,{children:".wait()"})," method will suspend its execution until the ",(0,t.jsx)(n.code,{children:".signaled"})," property is ",(0,t.jsx)(n.code,{children:"true"}),". While waiting for a signal, the calling process does not use any CPU. This can be very interesting for performance in multiprocess applications. The ",(0,t.jsx)(n.code,{children:".signaled"})," property becomes ",(0,t.jsx)(n.code,{children:"true"})," when any worker/process calls the ",(0,t.jsx)(n.code,{children:".trigger()"})," method."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that to avoid blocking situations, the ",(0,t.jsx)(n.code,{children:".wait()"})," can also return after a defined timeout has been reached."]}),"\n",(0,t.jsxs)(n.p,{children:["Signal objects are created with the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/language/commands/newSignal",children:"newSignal"})," command."]}),"\n",(0,t.jsx)(n.h3,{id:"working-with-signals",children:"Working with signals"}),"\n",(0,t.jsxs)(n.p,{children:["In QodlyScript, you create a new signal object by calling the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/language/commands/newSignal",children:(0,t.jsx)(n.code,{children:"newSignal"})})," command. Once created, this signal must be passed as a parameter to the ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/language/commands/callWorker",children:(0,t.jsx)(n.code,{children:"callWorker"})})," command so that it can modify it when it has finished the task you want to wait for."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"signal.wait()"})," must be called from the worker that needs another worker to finish a task in order to continue."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"signal.trigger()"})," must be called from the worker that finished its execution in order to release all others."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Once a signal has been released using a ",(0,t.jsx)(n.code,{children:"signal.trigger()"})," call, it cannot be reused again. If you want to set another signal, you need to call the ",(0,t.jsx)(n.code,{children:"newSignal"})," command again."]}),"\n",(0,t.jsxs)(n.p,{children:["Since a signal object is a ",(0,t.jsx)(n.a,{href:"/docs/1.0.0/language/basics/lang-shared",children:"shared object"}),", you can use it to return results from called workers, provided that you do not forget to write values within a ",(0,t.jsx)(n.code,{children:"use...end"})," structure (see example)."]}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-qs",children:' var signal : 4D.Signal\n\n  // Creation of a signal\n signal = newSignal\n\n  // call main process and execute OpenForm method\n callWorker(1,"OpenForm",signal)\n  // do another calculation\n ...\n  // Waiting for the end of the process\n signaled = signal.wait()\n\n  // Processing of the results\n calc = signal.result+...\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"OpenForm"})})," method :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-qs",children:' declare (signal : 4D.Signal)  \n var form : object\n form = newObject("value",0)\n\n  // Process the form object\n form = ...\n\n  // Add a new attribute to your signal shared object to pass your result to the other process:\n use(signal)\n    signal.result = form.value\n end\n\n  // Trigger the signal to the waiting process\n signal.trigger()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"functions-and-properties",children:"Functions and properties"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsx)(n.tr,{children:(0,t.jsx)(n.th,{})})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:[(0,t.jsxs)(n.a,{href:"#description",children:[(0,t.jsx)(n.strong,{children:".description"})," : string"]}),"\xa0\xa0\xa0\xa0contains a custom description for the ",(0,t.jsx)(n.code,{children:"signal"})," object."]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:[(0,t.jsxs)(n.a,{href:"#signaled",children:[(0,t.jsx)(n.strong,{children:".signaled"})," : Boolean"]}),"\xa0\xa0\xa0\xa0contains the current state of the ",(0,t.jsx)(n.code,{children:"signal"})," object"]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.a,{href:"#trigger",children:(0,t.jsx)(n.strong,{children:".trigger( )"})}),"\xa0\xa0\xa0\xa0sets the ",(0,t.jsx)(n.code,{children:"signaled"})," property of the signal object to ",(0,t.jsx)(n.strong,{children:"true"})]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:[(0,t.jsxs)(n.a,{href:"#wait",children:[(0,t.jsx)(n.strong,{children:".wait"}),"( { ",(0,t.jsx)(n.em,{children:"timeout"})," : number } ) : boolean "]}),"\xa0\xa0\xa0\xa0makes the current process wait until the ",(0,t.jsx)(n.code,{children:".signaled"})," property of the signal object to become ",(0,t.jsx)(n.strong,{children:"true"})," or the optional ",(0,t.jsx)(n.em,{children:"timeout"})," to expire"]})})]})]}),"\n",(0,t.jsx)(n.h2,{id:"description",children:".description"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:".description"})," : string"]}),"\n",(0,t.jsx)(n.h4,{id:"description-1",children:"Description"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:".description"})," property contains a custom description for the ",(0,t.jsx)(n.code,{children:"signal"})," object.."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:".description"})," can be set at the creation of the signal object or at any moment. Note that since the ",(0,t.jsx)(n.code,{children:"signal"})," object is a shared object, any write-mode access to the ",(0,t.jsx)(n.code,{children:".description"})," property must be surrounded by a ",(0,t.jsx)(n.code,{children:"use...end"})," structure."]}),"\n",(0,t.jsxs)(n.p,{children:["This property is ",(0,t.jsx)(n.strong,{children:"read-write"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"signaled",children:".signaled"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:".signaled"})," : Boolean"]}),"\n",(0,t.jsx)(n.h4,{id:"description-2",children:"Description"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:".signaled"})," property contains the current state of the ",(0,t.jsx)(n.code,{children:"signal"})," object. When the signal is created, ",(0,t.jsx)(n.code,{children:".signaled"})," is ",(0,t.jsx)(n.strong,{children:"false"}),". It becomes ",(0,t.jsx)(n.strong,{children:"true"})," when the ",(0,t.jsx)(n.code,{children:".trigger( )"})," is called on the object."]}),"\n",(0,t.jsxs)(n.p,{children:["This property is ",(0,t.jsx)(n.strong,{children:"read-only"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"trigger",children:".trigger()"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:".trigger( )"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{style:{textAlign:"center"}}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{style:{textAlign:"center"}}),(0,t.jsx)(n.td,{children:"Does not require any parameters"})]})})]}),"\n",(0,t.jsx)(n.h4,{id:"description-3",children:"Description"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:".trigger( )"})," function sets the ",(0,t.jsx)(n.code,{children:"signaled"})," property of the signal object to ",(0,t.jsx)(n.strong,{children:"true"})," and awakens all workers waiting for this signal."]}),"\n",(0,t.jsxs)(n.p,{children:["If the signal is already in the signaled state (i.e., the ",(0,t.jsx)(n.code,{children:"signaled"})," property is already ",(0,t.jsx)(n.strong,{children:"true"}),"), the function does nothing."]}),"\n",(0,t.jsx)(n.h2,{id:"wait",children:".wait()"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:".wait"}),"( { ",(0,t.jsx)(n.em,{children:"timeout"})," : number } ) : boolean"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"timeout"}),(0,t.jsx)(n.td,{children:"number"}),(0,t.jsx)(n.td,{children:"\u2192"}),(0,t.jsx)(n.td,{children:"Maximum waiting time for the signal in seconds"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Result"}),(0,t.jsx)(n.td,{children:"boolean"}),(0,t.jsx)(n.td,{children:"\u2190"}),(0,t.jsxs)(n.td,{children:["State of the ",(0,t.jsx)(n.code,{children:".signaled"})," property"]})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"description-4",children:"Description"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:".wait()"})," function makes the current process wait until the ",(0,t.jsx)(n.code,{children:".signaled"})," property of the signal object to become ",(0,t.jsx)(n.strong,{children:"true"})," or the optional ",(0,t.jsx)(n.em,{children:"timeout"})," to expire."]}),"\n",(0,t.jsxs)(n.p,{children:["To prevent blocking code, you can pass a maximum waiting time in seconds in the ",(0,t.jsx)(n.em,{children:"timeout"})," parameter (decimals are accepted)."]}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["Calling ",(0,t.jsx)(n.code,{children:".wait()"})," without a ",(0,t.jsx)(n.em,{children:"timeout"})," in the Qodly main process is not recommended because it could freeze the whole Qodly application."]})}),"\n",(0,t.jsxs)(n.p,{children:["If the signal is already in the signaled state (i.e. the ",(0,t.jsx)(n.code,{children:".signaled"})," property is already ",(0,t.jsx)(n.strong,{children:"true"}),"), the function returns immediately, without waiting."]}),"\n",(0,t.jsxs)(n.p,{children:["The function returns the value of the ",(0,t.jsx)(n.code,{children:".signaled"})," property. Evaluating this value allows knowing if the function returned because the ",(0,t.jsx)(n.code,{children:".trigger( )"})," has been called (",(0,t.jsx)(n.code,{children:".signaled"})," is ",(0,t.jsx)(n.strong,{children:"true"}),") or if the ",(0,t.jsx)(n.em,{children:"timeout"})," expired (",(0,t.jsx)(n.code,{children:".signaled"})," is ",(0,t.jsx)(n.strong,{children:"false"}),")."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["The state of a process that waits for a signal is ",(0,t.jsx)(n.code,{children:"Waiting for internal flag"}),"."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},50065:function(e,n,s){s.d(n,{Z:function(){return l},a:function(){return o}});var i=s(67294);let t={},r=i.createContext(t);function o(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);