"use strict";(self.webpackChunkqodly=self.webpackChunkqodly||[]).push([["47556"],{2618:function(e,t,n){n.r(t),n.d(t,{metadata:()=>s,contentTitle:()=>o,default:()=>h,assets:()=>d,toc:()=>c,frontMatter:()=>l});var s=JSON.parse('{"id":"language/commands/jsonResolvePointers","title":"jsonResolvePointers","description":"jsonResolvePointers ( aObject object) : object","source":"@site/versioned_docs/version-1.0.0/language/commands/jsonResolvePointers.md","sourceDirName":"language/commands","slug":"/language/commands/jsonResolvePointers","permalink":"/docs/1.0.0/language/commands/jsonResolvePointers","draft":false,"unlisted":false,"editUrl":"https://github.com/qodly/docs/issues/new?title=Comment%20on%20language%2Fcommands%2FjsonResolvePointers.md%20(1.0.0)&body=Share%20any%20feedback%20about%20this%20page%20%E2%80%94%20report%20issues%2C%20suggest%20improvements%2C%20or%20tell%20us%20what%E2%80%99s%20helpful.%0A%0AIf%20it%E2%80%99s%20an%20issue%3A%0A-%20What%E2%80%99s%20the%20issue%3F%20(e.g.%2C%20typo%2C%20incorrect%20information%2C%20unclear%20explanation)%0A-%20Where%20is%20it%3F%20(e.g.%2C%20section%20name%2C%20specific%20paragraph%2C%20or%20line)%0A%0AThank%20you%20for%20helping%20us%20improve!%20%F0%9F%9A%80%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20","tags":[],"version":"1.0.0","frontMatter":{"id":"jsonResolvePointers","title":"jsonResolvePointers"},"sidebar":"Develop","previous":{"title":"jsonParse","permalink":"/docs/1.0.0/language/commands/jsonParse"},"next":{"title":"jsonStringify","permalink":"/docs/1.0.0/language/commands/jsonStringify"}}'),i=n("85893"),r=n("50065");let l={id:"jsonResolvePointers",title:"jsonResolvePointers"},o=void 0,d={},c=[{value:"Description",id:"description",level:4},{value:"Defining JSON Pointers",id:"defining-json-pointers",level:4},{value:"Recursivity and path resolution",id:"recursivity-and-path-resolution",level:4}];function a(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"jsonResolvePointers"})," ( ",(0,i.jsx)(t.em,{children:"aObject"})," : object , ",(0,i.jsx)(t.em,{children:"options"})," : object) : object"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"center"}}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"aObject"}),(0,i.jsx)(t.td,{children:"object"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"\u2192"}),(0,i.jsx)(t.td,{children:"Object containing JSON pointers to resolve"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"\u2190"}),(0,i.jsx)(t.td,{children:"Object with JSON pointers resolved (only if result is an object)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"options"}),(0,i.jsx)(t.td,{children:"object"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"\u2192"}),(0,i.jsx)(t.td,{children:"Options for pointer resolution"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Result"}),(0,i.jsx)(t.td,{children:"object"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"\u2190"}),(0,i.jsx)(t.td,{children:"Object containing the result of the processing"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"jsonResolvePointers"})," command resolves all the JSON pointers found in the ",(0,i.jsx)(t.em,{children:"aObject"}),", with regards to ",(0,i.jsx)(t.em,{children:"options"})," settings (if any)."]}),"\n",(0,i.jsx)(t.p,{children:"JSON pointers are particularily useful to:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"embed some part of an external JSON document or reuse a part of a JSON document in other places in the same JSON document, in order to factorize information,"}),"\n",(0,i.jsx)(t.li,{children:"express a cyclic structure in JSON,"}),"\n",(0,i.jsx)(t.li,{children:"define a template object containing default properties stored in JSON."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Pass in the ",(0,i.jsx)(t.em,{children:"aObject"})," parameter an object containing JSON pointers to be resolved (for information on JSON pointer syntax, please refer to the ",(0,i.jsx)(t.a,{href:"#defining-json-pointers",children:(0,i.jsx)(t.code,{children:"Defining JSON Pointers"})})," paragraph below)."]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["The source ",(0,i.jsx)(t.em,{children:"aObject"})," will be updated with the result of pointer resolution after the command is executed (except if the result is not an object, see below). If you want to keep an original version of ",(0,i.jsx)(t.em,{children:"aObject"}),", you may consider using the objectCopy beforehand."]})}),"\n",(0,i.jsxs)(t.p,{children:["Optionally, you can pass in options an ",(0,i.jsx)(t.em,{children:"aObject"})," containing specific properties to be used when resolving pointers. The following properties are supported:"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Property"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Value type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"rootFolder"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"string"}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["Absolute path (using standard Qodly syntax) to the folder to be used to resolve relative pointers in ",(0,i.jsx)(t.em,{children:"aObject"}),". Default is the database Resources folder."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"merge"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"boolean"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Merge objects with pointer objects (true) instead of replacing them (false). Default is false"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"After the command is executed:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["if the result of pointer resolution is an object, ",(0,i.jsx)(t.em,{children:"aObject"})," is updated and contains the resulting object."]}),"\n",(0,i.jsxs)(t.li,{children:["if the result of pointer resolution is a scalar value (i.e. a text, a number...), ",(0,i.jsx)(t.em,{children:"aObject"}),' is left untouched and the resulting value is returned in the "value" property of the function result.']}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"In any cases, the command returns an object containing the following properties:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Property"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Value type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"value"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"any"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Result of the command processing on object. If the result is an object, it is equal to output object."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"success"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"boolean"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"true if all pointers have been resolved successfully"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"errors"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"collection"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Collection of errors if any"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"errors[].code"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"number"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"error code"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"errors[].message"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"string"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"error message"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"errors[].pointerURI"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"string"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"pointer value"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"errors[].referredPath"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"string"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"document fullpath"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"defining-json-pointers",children:"Defining JSON Pointers"}),"\n",(0,i.jsxs)(t.p,{children:["JSON Pointer is a standard that defines a string syntax which can be used to access a particular field or key value in the entire JSON document. The standard has been described in the ",(0,i.jsx)(t.a,{href:"https://tools.ietf.org/html/rfc6901",children:(0,i.jsx)(t.code,{children:"RFC 6901"})}),"."]}),"\n",(0,i.jsx)(t.p,{children:"A JSON pointer is, strictly speaking, a string composed of parts separated by '/'. A JSON pointer is usually found in a URI that specifies the document into which the pointer will be resolved. The fragment character \"#' is used in the URI to specify the JSON pointer. By convention, a URI containing a JSON pointer can be found in a JSON object property that must be named \"ref\"."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'{    "ref":<path>#<json_pointer> }\n'})}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:'Qodly does not support the "-" character as reference to nonexistent arrray elements.'})}),"\n",(0,i.jsx)(t.h4,{id:"recursivity-and-path-resolution",children:"Recursivity and path resolution"}),"\n",(0,i.jsx)(t.p,{children:"JSON pointers are resolved recursively, which means that if a resolved pointer also contains pointers, they are resolved recursively and so on, until all pointers are resolved. In this context, all file paths found in JSON pointer URIs can be relative or absolute. They must use '/' as path delimiter and are resolved the following way:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"A relative path must not start with '/'. It is resolved relatively to the JSON document where the path string has been found,"}),"\n",(0,i.jsx)(t.li,{children:'An absolute path starts with \'/\'. Only filesystem pathnames are accepted as absolute paths. For example, "/SOURCES/Shared/templates/myfile.json" points to the file "myfile.json" located in the current database resources folder.'}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The name resolution is case sensitive."}),"\n",(0,i.jsx)(t.li,{children:'Qodly does not resolve a path to a json file located over the network (starting with "http/https").'}),"\n"]})})]})}function h(e={}){let{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},50065:function(e,t,n){n.d(t,{Z:function(){return o},a:function(){return l}});var s=n(67294);let i={},r=s.createContext(i);function l(e){let t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);